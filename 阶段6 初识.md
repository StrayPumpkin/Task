# TCP/IP

**应用层**的主要协议有HTTP(万维网服务、FTP（文件传输）、SMTP（电子邮件）SSH（安全远程登陆）、DNS（域名解析）等，是用来**读取来自传输层的数据或者将数据传输写入传输层**

**传输层**的主要协议有UDP(不可靠传输)、TCP(可靠传输)，**实现端对端的数据传输**；

**网络层**的主要协议有ICMP、IP、IGMP，主要**负责网络中数据包的传送等**；

**链路层**有时也称作数据链路层或网络接口层，主要协议有ARP、RARP，通常包括**操作系统中的设备驱动程序和计算机中对应的网络接口卡，它们一起处理与传输媒介（如电缆或其他物理设备）的物理接口细节。**	

​	

​		起初人们通过**集线器**（物理层面）把多个电脑连接，把电脑A的数据发给电脑B时通过集线器发给所有电脑，在通过MAC地址来判断电脑B是接受还是丢弃。但原来只要发给电脑 B 的消息，却要发给连接到集线器中的所有电脑，这样既不安全，又不节省网络资源

​		**交换机**的出现实现了电脑的”一对一“沟通，在初次使用时MAC地址表是空的，电脑A的数据发给电脑B时，设A为端口3，B为端口1，该过程完成后，MAC地址表就有了两条数据

```
MAC：aa-aa-aa-aa-aa-aa-aa
端口：3

MAC：bb-bb-bb-bb-bb-bb
端口：1
```

在不断的通信中，MAC地址表建立完毕。

​		当连接的电脑数目不断增加，交换机已无法记录，因此**路由器**应运而生，它有独立的MAC地址，同时可以把数据包一次转发。路由器的每一个端口，都有独立的 MAC 地址。

​		由于MAC地址是不可修改的，这使路由器同时传给多个设备变得麻烦，因此又有了**IP地址**，它是在软件层面的，可以随时修改。路由器的工作就是专门负责IP地址的寻找

​		对 电脑A 来说，A 只能**直接**把包发给同处于一个子网下的某个 IP 上，所以发给路由器还是发给某个电脑，对 A 来说也不关心，只要这个设备有个 IP 地址就行。

​		所以**默认网关，就是 A 在自己电脑里配置的一个 IP 地址**，以便在发给不同子网的机器时，发给这个 IP 地址。

​		当我们仅知道电脑的IP地址不知道MAC地址时，通过arp协议来查找，与MAC表类似，一开始arp缓存表是空的，A为了知道B的 MAC 地址，将会**广播**一条 arp 请求，B 收到请求后，带上自己的 MAC 地址给 A 一个**响应**。此时 A 便更新了自己的 arp 表。

## 特点

1. 开放性标准化

   独立于硬件和操作系统，可在不同平台运行，支持全球互联。

2. 灵活性

   - 支持多种网络类型（如以太网、Wi-Fi、光纤等）。
   - 可以适应不同规模的网络，从小型局域网到全球互联网。
   - 支持多种应用协议（如 HTTP、FTP、SMTP 等）。

3. 可拓展性

   通过 **IP 地址** 和 **路由协议**，TCP/IP 可以支持不断增长的网络规模。

4. 无连接和面向连接并存

5. 高效的路由机制

   使用动态路由协议（OSPF,BGP)自动选择最佳路径

6. 跨平台兼容

    可以在各种硬件和操作系统上运行，包括 Windows、Linux、macOS、路由器、物联网设备等。

## TCP协议的报文格式

![](https://github.com/StrayPumpkin/img/blob/main/tcp%E6%8A%A5%E6%96%87.png?raw=true)

1.**源端口号**——表示报文的发送端口，占16位。源端口和源IP地址组合起来，可以标识报文的发送地址。

2.**目的端口号**——表示报文的接收端口，占16位。目的端口和目的IP地址相结合，可以标识报文的接收地址。

3.**序号**（Seq）**（SN)**——语义与SYN控制标志的值有关。

- 当SYN = 1时，当前为连接建立阶段，此时的序号为初始序号ISN((Initial Sequence Number)，通过算法来随机生成序号；
- 当SYN = 0时在数据传输正式开始时，第一个报文的序号为 ISN + 1，后面的报文的序号，为前一个报文的SN值+TCP报文的净荷字节数(不包含TCP头)。

4.**确认序号**（Ack）**(AN)**——标识了报文接收端期望接收的字节序列。如果设置了ACK控制位，确认序号的值表示一个准备接收的包的序列码，注意，它所指向的是准备接收的包，也就是下一个期望接收的包的序列码

5.**头部长度**——该字段占用4位，用来表示TCP报文首部的长度，单位是4bit位。

6.**预留6位**——头部长度后面预留的字段长度为6位，作为保留字段，暂时没有什么用处。

7.**控制标志**——共6个bit位，具体的标志位为：URG、ACK、PSH、RST、SYN、FIN。6个标志位的说明——

- URG

  占1位，表示紧急指针字段有效。URG位指示报文段里的上层实体（数据）标记为“紧急”数据。当URG=1时，其后的紧急指针指示紧急数据在当前数据段中的位置(相对于当前序列号的字节偏移量)，TCP接收方必须通知上层实体。

- ACK

  占1位，置位ACK=1表示确认号字段有效；TCP协议规定，接建立后所有发送的报文的ACK必须为1；当ACK=0时，表示该数据段不包含确认信息。当ACK=1时，表示该报文段包括一个对已被成功接收报文段的确认序号Acknowledgment Number，该序号同时也是下一个报文的预期序号。

- PSH

  占1位，表示当前报文需要请求推（push）操作；当PSH=1时，接收方在收到数据后立即将数据交给上层，而不是直到整个缓冲区满。

- RST

  占1位，置位RST=1表示复位TCP连接；用于重置一个已经混乱的连接，也可用于拒绝一个无效的数据段或者拒绝一个连接请求。如果数据段被设置了RST位，说明报文发送方有问题发生。

- SYN

  占1位，在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使SYN=1和ACK=1。 综合一下，SYN置1就表示这是一个连接请求或连接接受报文。

- FIN

  占1位，用于在释放TCP连接时，标识发送方比特流结束，用来释放一个连接。当 FIN = 1时，表明此报文的发送方的数据已经发送完毕，并要求释放连接。


8.窗口大小——长度为16位，共2个字节。此字段用来进行流量控制。流量控制的单位为字节数，这个值是本端期望一次接收的字节数。

9.校验和计算——长度为16位，共2个字节。对整个TCP报文段，即TCP头部和TCP数据进行校验和计算，接收端用于对收到的数据包进行验证。

10.紧急指针——长度为16位，2个字节。它是一个偏移量，和SN序号值相加表示紧急数据最后一个字节的序号。

11.可选项和填充部分——可选项和填充部分的长度为4n字节（n是整数），该部分是根据需要而增加的选项。如果不足4n字节，要加填充位，使得选项长度为32位（4字节）的整数倍，具体的做法是在这个字段中加入额外的零，以确保TCP头是32位（4字节）的整数倍。

​		TCP报文首部的后面，接着的是数据部分，不过数据部分是可选的。在一个连接建立和一个连接终止时，双方交换的报文段仅有TCP首部。如果一方没有数据要发送，也使用没有任何数据的首部来确认收到的数据，比如在处理超时的过程中，也会发送不带任何数据的报文段。

### 示例

假设一个 TCP 报文的结构如下：

- 源端口号：12345
- 目的端口号：80
- 序列号：1000
- 确认号：2000
- 数据偏移：5（头部长度为 20 字节）
- 控制位：ACK=1, PSH=1
- 窗口大小：4096
- 校验和：0xABCD
- 紧急指针：0
- 数据部分：Hello World

## 建立联接——TCP的三次握手

![](https://raw.githubusercontent.com/StrayPumpkin/img/main/b96dd000dacaff01362d76df75987a85.png)

**第一次握手**：Client进入SYN_SENT状态，发送一个SYN帧来主动打开传输通道，该帧的SYN标志位被设置为1，同时会带上Client分配好的SN序列号，该SN是根据时间产生的一个随机值，通常情况下每间隔4ms会加1。除此之外，SYN帧还会带一个MSS（最大报文段长度)可选项的值，表示客户端发送出去的最大数据块的长度。

**第二次握手**：Server端在收到SYN帧之后，会进入SYN_RCVD状态，同时返回SYN+ACK帧给Client，主要目的在于通知Client，Server端已经收到SYN消息，现在需要进行确认。Server端发出的SYN+ACK帧的ACK标志位被设置为1，其确认序号AN值被设置为Client的SN+1；SYN+ACK帧的SYN标志位被设置为1，SN值为Server端生成的SN序号；SYN+ACK帧的MSS（最大报文段长度）表示的是Server端的最大数据块长度。

**第三次握手**：Client在收到Server的第二次握手SYN+ACK确认帧之后，首先将自己的状态会从SYN_SENT变成ESTABLISHED，表示自己方向的连接通道已经建立成功，Client可以发送数据给Server端了。然后，Client发ACK帧给Server端，该ACK帧的ACK标志位被设置为1，其确认序号AN值被设置为Server端的SN序列号+1。还有一种情况，Client可能会将ACK帧和第一帧要发送的数据，合并到一起发送给Server端。

Server端在收到Client的ACK帧之后，会从SYN_RCVD状态会进入ESTABLISHED状态，至此，Server方向的通道连接建立成功，Server可以发送数据给Client，TCP的全双工连接建立完成。



## 断开连接——四次挥手

![](https://raw.githubusercontent.com/StrayPumpkin/img/refs/heads/main/4ea28282b0cc856da9edbf68c335405b.png)

**第一次挥手**：主动断开方（可以是客户端，也可以是服务器端），向对方发送一个FIN结束请求报文，此报文的FIN位被设置为1，并且正确设置SN和AN。发送完成后，主动断开方进入FIN_WAIT_1状态，这表示主动断开方没有业务数据要发送给对方，准备关闭SOCKET连接了。

**第二次挥手**：正常情况下，在收到了主动断开方发送的FIN断开请求报文后，被动断开方会发送一个ACK响应报文，报文的AN值为断开请求报文的SN值加1，该ACK确认报文的含义是：“我同意你的连接断开请求”。之后，被动断开方就进入了CLOSE-WAIT（关闭等待）状态，TCP协议服务会通知高层的应用进程，对方向本地方向的连接已经关闭，对方已经没有数据要发送了，若本地还要发送数据给对方，对方依然会接受。被动断开方的CLOSE-WAIT（关闭等待）还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。

主动断开方在收到了ACK报文后，由FIN_WAIT_1转换成FIN_WAIT_2状态。

**第三次挥手**：在发送完成ACK报文后，被动断开方还可以继续完成业务数据的发送，待剩余数据发送完成后，或者CLOSE-WAIT（关闭等待）截止后，被动断开方会向主动断开方发送一个FIN+ACK结束响应报文，表示被动断开方的数据都发送完了，然后，被动断开方进入LAST_ACK状态。

**第四次挥手**：主动断开方收在到FIN+ACK断开响应报文后，还需要进行最后的确认，向被动断开方发送一个ACK确认报文，然后，自己就进入TIME_WAIT状态，等待超时后最终关闭连接。处于TIME_WAIT状态的主动断开方，在等待完成2MSL的时间后，如果期间没有收到其他报文，则证明对方已正常关闭，主动断开方的连接最终关闭。

- **2MSL**翻译过来就是两倍的MSL。MSL全称为Maximum Segment Lifetime，指的是一个TCP报文片段在网络中最大的存活时间，

被动断开方在收到主动断开方的最后的ACK报文以后，最终关闭了连接
